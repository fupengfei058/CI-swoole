    <?php

class HttpServer
{
	public $http;
	public $response = null;
	public static $instance;
    public static $get;
    public static $post;
    public static $header;
    public static $server;

	function __construct()
	{
		$http = new swoole_http_server("0.0.0.0", 9501);
		$http->set (array(
			'worker_num' => 2,		//worker进程数量
			'daemonize' => false,	//守护进程设置成true
			'max_request' => 1000,	//最大请求次数，当请求大于它时，将会自动重启该worker
			'dispatch_mode' => 1 
		));
		$http->on('WorkerStart', array($this, 'onWorkerStart'));
		$http->on('request', array($this, 'onRequest'));
		$http->start();
	}

	public function onWorkerStart($serv, $worker_id)
	{
		include_once './httpindex.php';
	}

	public function onRequest($request, $response)
	{
        register_shutdown_function(array($this, 'handleFatal'));
		try {
            $this->response = $response;
            if (isset($request->server)) {
                HttpServer::$server = $request->server;
                foreach ($request->server as $key => $value) {
                    $_SERVER[strtoupper($key)] = $value;
                }
            }
            if (isset($request->header)) {
                HttpServer::$header = $request->header;
            }
            if (isset($request->get)) {
                HttpServer::$get = $request->get;
                foreach ($request->get as $key => $value) {
                    $_GET[$key] = $value;
                }
            }
            if (isset($request->post)) {
                HttpServer::$post = $request->post;
                foreach ($request->post as $key => $value) {
                    $_POST[$key] = $value;
                }
            }
            ob_start();
            Httpindex::getInstance();
			$result = ob_get_contents();
            ob_end_clean();
			$result = empty($result) ? 'No message' : $result;
			$response->end($result);
			unset($result);
		} catch (Exception $e) {
			$response->end($e->getMessage());
		}
	}

    /**
     * 致命错误处理
     */
    public function handleFatal()
    {
        $error = error_get_last();
        if (isset($error['type'])) {
            switch ($error['type']) {
                case E_ERROR :
                    $severity = 'ERROR:Fatal run-time errors. Errors that can not be recovered from. Execution of the script is halted';
                    break;
                case E_PARSE :
                    $severity = 'PARSE:Compile-time parse errors. Parse errors should only be generated by the parser';
                    break;
                case E_DEPRECATED:
                    $severity = 'DEPRECATED:Run-time notices. Enable this to receive warnings about code that will not work in future versions';
                    break;
                case E_CORE_ERROR :
                    $severity = 'CORE_ERROR :Fatal errors at PHP startup. This is like an E_ERROR in the PHP core';
                    break;
                case E_COMPILE_ERROR :
                    $severity = 'COMPILE ERROR:Fatal compile-time errors. This is like an E_ERROR generated by the Zend Scripting Engine';
                    break;
                default:
                    $severity = 'OTHER ERROR';
                    break;
            }
            $message = $error['message'];
            $file = $error['file'];
            $line = $error['line'];
            $log = "$message ($file:$line)\nStack trace:\n";
            $trace = debug_backtrace();
            foreach ($trace as $i => $t) {
                if (!isset($t['file'])) {
                    $t['file'] = 'unknown';
                }
                if (!isset($t['line'])) {
                    $t['line'] = 0;
                }
                if (!isset($t['function'])) {
                    $t['function'] = 'unknown';
                }
                $log .= "#$i {$t['file']}({$t['line']}): ";
                if (isset($t['object']) && is_object($t['object'])) {
                    $log .= get_class($t['object']) . '->';
                }
                $log .= "{$t['function']}()\n";
            }
            if (isset($_SERVER['REQUEST_URI'])) {
                $log .= '[QUERY] ' . $_SERVER['REQUEST_URI'];
            }
            log_message('error', $log);
            if($this->response) {
                $this->response->end($log);
            }
        }
    }

    public static function getInstance()
    {
        if (!self::$instance) {
            self::$instance = new HttpServer;
        }
        return self::$instance;
    }
}

HttpServer::getInstance();